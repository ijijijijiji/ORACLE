SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;
select * from JOBS;
select * from COUNTRIES;
select * from LOCATIONS;
select * from REGIONS;
select * from JOB_HISTORY;
select * from EMP_DETAILS_VIEW;

1. 연봉이 12000 이상되는 직원들의 LAST_NAME 및 연봉을 조회한다.
SELECT LAST_NAME,  SALARY FROM EMPLOYEES
where SALARY >=12000;

2. 사원번호가 176 인 사람의 LAST_NAME 과 부서 번호를 조회한다.
SELECT  LAST_NAME, DEPARTMENT_ID FROM EMPLOYEES
where EMPLOYEE_ID = 176;

3. 연봉이 5000 에서 12000의 범위 이외인 사람들의 LAST_NAME 및 연봉을 조회한다.
SELECT  LAST_NAME ,  SALARY FROM EMPLOYEES
WHERE SALARY <5000 OR SALARY > 12000;
WHERE NOT SALARY BETWEEN 5000 AND 12000;
WHERE NOT (SALARY >= 5000 AND SALARY <=12000);

4. 2002/02/20 일부터 2008/05/01 사이에 고용된 사원들의 LAST_NAME, 사번, 고용일자를 조회한다.
SELECT  LAST_NAME  , EMPLOYEE_ID , HIRE_DATE FROM  EMPLOYEES
WHERE HIRE_DATE >= '2002/02/20' AND HIRE_DATE <= '2008/05/01';
WHERE HIRE_DATE BETWEEN '2002/02/20' AND '2008/05/01';

5. 20 번 및 50 번 부서에서 근무하는 모든 사원들의 LAST_NAME 및 부서 번호를  조회한다. 단, LAST_NAME의 알파벳순으로 정렬한다.
SELECT  LAST_NAME, DEPARTMENT_ID FROM    EMPLOYEES
WHERE DEPARTMENT_ID=20 OR DEPARTMENT_ID=50 ORDER BY LAST_NAME ASC;
WHERE DEPARTMENT_ID IN(20,50) ORDER BY LAST_NAME ASC;

6. 20 번 및 50 번 부서에 근무하며, 연봉이 5000 ~ 12,000 사이인 사원들의 LAST_NAME 및 연봉을 조회한다.
SELECT  LAST_NAME ,  SALARY FROM EMPLOYEES
WHERE DEPARTMENT_ID IN(20,50) AND SALARY BETWEEN 5000 AND 12000;

7. 2004년도에 고용된 모든 사람들의 LAST_NAME 및 고용일을 조회한다.
SELECT  LAST_NAME , HIRE_DATE FROM    EMPLOYEES
WHERE HIRE_DATE LIKE '04%';

8-1. 매니저가 없는 사람들의 LAST_NAME 및 JOB_ID 를 조회한다.
SELECT  LAST_NAME , JOB_ID   FROM    EMPLOYEES
WHERE   MANAGER_ID is NULL
OR MANAGER_ID = '';

8-2. 매니저가 있는 사람들의 LAST_NAME 및 JOB_ID 를 조회한다.
SELECT  LAST_NAME , JOB_ID   FROM    EMPLOYEES
WHERE   MANAGER_ID is NOT NULL
OR MANAGER_ID != '';

9. 커미션을 버는 모든 사원들의 LAST_NAME, 연봉 및 커미션을 조회한다.
--    연봉 역순, 커미션 역순차로 정렬한다.
SELECT  LAST_NAME , SALARY, COMMISSION_PCT FROM EMPLOYEES
WHERE NOT(COMMISSION_PCT IS NULL)
ORDER BY SALARY DESC, COMMISSION_PCT DESC;

10. LAST_NAME 의 네번째 글자가 a 인 사원들의 LAST_NAME 을 조회한다.
SELECT  LAST_NAME FROM   EMPLOYEES WHERE LAST_NAME LIKE '___a%';

11. LAST_NAME 에 a 및(OR) e 글자가 있는 사원들의 LAST_NAME 을 조회한다.
SELECT  LAST_NAME FROM   EMPLOYEES WHERE LAST_NAME LIKE '%a%' OR LAST_NAME LIKE '%e%';

12. 연봉이 2,500, 3,500, 7000 이 아니며 직업이 SA_REP 이나 ST_CLERK 인 사람들을 조회한다.(LAST_NAME, SALARY, JOB_ID)
SELECT LAST_NAME, SALARY, JOB_ID FROM  EMPLOYEES
WHERE SALARY NOT IN(2500, 3500, 7000) AND JOB_ID IN('SA_REP','ST_CLERK');

13.직업이 AD_PRES 인 사람은 A 등급을, ST_MAN 인 사람은 B 등급을, IT_PROG 인 사람은 C 등급을,
         SA_REP 인 사람은 D 등급을, ST_CLERK 인 사람은 E 등급을 기타는 0 을 부여하여 조회한다.
         (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, GRADE)

13-1 DECODE 함수를 이용하시오.
DECODE(조건의 대상이 되는 컬럼명, 조건1, 1에 부합될 때 출력값, 조건2, 2에 부합될 때 출력값,..... , 어떤 조건에도 맞지 않을 때의 출력값) AS 별칭

SELECT  EMPLOYEE_ID        , FIRST_NAME        , LAST_NAME,
DECODE(JOB_ID, 'AD_PRES','A','ST_MAN','B','IT_PROG','C','SA_REP','D','ST_CLERK','E','0') AS GRADE
FROM  EMPLOYEES;

13-2 CASE 문 이용하시오.
CASE 조건의 대상이 되는 컬럼명 WHEN 조건1 THEN 조건1이 참일 때 결과
                         WHEN 조건2 THEN 조건2이 참일 때 결과...    
                         ....
                         ELSE 어떤 조건에도 맞지 않을 때의 출력값
                         END AS 별칭
                         
SELECT  EMPLOYEE_ID, FIRST_NAME, LAST_NAME,    CASE JOB_ID WHEN 'AD_PRES' THEN 'A'    
                                                        WHEN  'ST_MAN' THEN 'B'
                                                        WHEN  'IT_PROG' THEN 'C'
                                                        WHEN  'SA_REP' THEN 'D'
                                                        WHEN  'ST_CLERK' THEN 'E'
                                                        ELSE '0'
                                                        END AS GRADE FROM  EMPLOYEES;

14. 모든 사원들의 LAST_NAME, 부서 이름 및 부서 번호을 조회한다.
SELECT E.LAST_NAME, D.DEPARTMENT_NAME, E.DEPARTMENT_ID FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;

15. 부서번호 30과 90의 모든 직업들을 유일한 포맷(중복제외)으로 조회한다.
JOB_ID, DEPARTMENT_ID, DEPARTMENT_NAME를 출력하고 JOB_ID 오름차순으로 정렬하시오.
SELECT DISTINCT E.JOB_ID, E.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND D.DEPARTMENT_ID IN(30,90)
ORDER BY E.JOB_ID;

16-1. 커미션을 버는 모든 사람들의 LAST_NAME, 부서 명, 지역 ID 및 도시 명을 조회한다.
SELECT E.LAST_NAME, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID AND  D.LOCATION_ID = L.LOCATION_ID
AND E.COMMISSION_PCT IS NOT NULL;

16-2. 옥스포드에 사는 사람 중 커미션을 버는 모든 사람들의 LAST_NAME, 부서 명, 지역 ID 및 도시 명을 조회한다.
SELECT E.LAST_NAME, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY /*(SELECT CITY FROM LOCATIONS WHERE CITY ='Oxford')*/
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID AND  D.LOCATION_ID = L.LOCATION_ID
AND E.COMMISSION_PCT IS NOT NULL
AND L.CITY = 'Oxford';/*Oxford를 검색하는 서브쿼리를 이용하여 쿼리문을 작성하시오.*/
/*LOCATION_ID = (SELECT LOCAION_ID FROM LOCATIONS WHERE CITY = 'Oxford') */

 17. LAST_NAME 이 Davies 인 사람보다 후에 고용된 사원들의 LAST_NAME 및 HIRE_DATE 을 조회한다.(조건문에 서브쿼리 사용)
 SELECT LAST_NAME, HIRE_DATE FROM EMPLOYEES
 WHERE  HIRE_DATE > (SELECT HIRE_DATE FROM EMPLOYEES WHERE LAST_NAME = 'Davies');/*Davies의 고용일을 조회하는 서브쿼리*/
 
 18. Popp보다 급여가 높은 사원의 LAST_NAME과 급여를 조회하시오.(서브쿼리이용)
SELECT LAST_NAME, SALARY FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE LAST_NAME = 'Popp');/*Popp의 급여*/

19. 부서번호가 100인 부서에 속한 사원 중 전체 사원의 평균급여보다 높은 급여를 받는 사원의 LAST_NAME, 급여, 소속부서명을 조회하시오.
(조건문에 서브쿼리 이용)
SELECT LAST_NAME, SALARY, DEPARTMENT_NAME FROM EMPLOYEES E , DEPARTMENTS D
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.DEPARTMENT_ID = 100
AND E.SALARY > ( SELECT AVG(SALARY) FROM EMPLOYEES);/*평균급여 구하는 서브쿼리*/

20.각부서별 최고 급여(조건문에서 서브쿼리로 조회)를 받는 사람의 LAST_NAME, 급여, 소속부서명을 조회하시오.
SELECT E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME FROM EMPLOYEES E , DEPARTMENTS D
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND (D.DEPARTMENT_ID, E.SALARY) IN (SELECT DEPARTMENT_ID , MAX(SALARY) FROM EMPLOYEES
                                GROUP BY DEPARTMENT_ID) /* (각 부서별 최고 급여)*/ 

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'LOCATIONS';/*테이블의 제약조건확인*/
DESC LOCATIONS; /*DESC 테이블명 : 테이블의 구조확인, NOT NULL 제약조건, 데이터형식 확인*/


***group by***
SELECT 조회하고자 하는 컬럼명,,, 연산식, 함수식....
FROM...
WHERE....
GROUP BY (SELECT 절에서 조회하고자 했던 컬럼명들)

- 부서별, 직책별, 평균 급여를 구하여라.
(부서이름, 평균급여를 화면 출력)
1) 부서이름과 모든 급여 정보를 조회
SELECT D.DEPARTMENT_NAME, E.SALARY FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
2) 부서별 평균급여
SELECT D.DEPARTMENT_NAME, AVG(E.SALARY) FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID GROUP BY D.DEPARTMENT_NAME;
3)부서별, 직책별 평균급여
SELECT D.DEPARTMENT_NAME, E.JOB_ID, AVG(E.SALARY) FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID GROUP BY D.DEPARTMENT_NAME, E.JOB_ID;

-HAVING(이미 가공처리된 정보에서 사용되는 조건절)
4) 부서별, 직책별 평균 급여 중 6000 이상인 정보(부서명, 직책명, 평균급여)만 조회하시오.
SELECT D.DEPARTMENT_NAME, E.JOB_ID, E.SALARY FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.SALARY >=6000; /* 원본 정보에 대한 조건*/


SELECT D.DEPARTMENT_NAME, E.JOB_ID, AVG(E.SALARY) FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID  
GROUP BY D.DEPARTMENT_NAME, E.JOB_ID HAVING AVG(E.SALARY) >=6000;/* GROUP BY를 통해 가공된 정보*/

5) 급여총액이 6000미만인 직원들이 속한 부서별 평균급여가 3000이상인 부서의 최대급여, 최소급여를 구하라.
( 부서명, 평균급여, 최대급여, 최소급여 출력)
SELECT D.DEPARTMENT_NAME, AVG(E.SALARY),  MAX(E.SALARY),  MIN(E.SALARY)
FROM EMPLOYEES E , DEPARTMENTS D WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID  
AND E.SALARY < 6000
GROUP BY D.DEPARTMENT_NAME
HAVING AVG(E.SALARY) >= 3000;

21.부서번호가 100 사원의 사원번호, LAST_NAME, 부서이름을 조회하시오. (인라인뷰 사용)
 /* 인라인 뷰란, select 문의 결과로 보여지는 가상테이블(뷰)을 실제 테이블처럼 쿼리문에서 이용하는 기법, 즉 from 절에서 이용*/
SELECT E100.EMPLOYEE_ID, E100.LAST_NAME, D.DEPARTMENT_NAME
FROM (SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 100/*부서번호가 100인 사원들의 정보*/) E100
    , DEPARTMENTS D
WHERE E100.DEPARTMENT_ID = D.DEPARTMENT_ID;

22.사원들의 LAST_NAME, 부서번호, 부서명(스칼라 서브쿼리로 조회)을 조회하시오.(스칼라서브쿼리--SELECT절에 사용하는 쿼리-- 이용)
SELECT LAST_NAME, DEPARTMENT_ID,
   (SELECT D.DEPARTMENT_NAME FROM DEPARTMENTS D WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID)
        /*부서명이 조회되는 서브쿼리*/
FROM EMPLOYEES E;

23. 전체 사원 중 Austin과 같은 직책(job_id)/*서브쿼리로*/ 인 사원들의 사원번호와 부서명을 출력하시오.
SELECT E.EMPLOYEE_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE LAST_NAME = 'Austin' /*Austin의 JOB_ID*/)
;

24. 전체 사원의 평균급여(/*서브쿼리*/)보다 높은 급여를 받는 사원들의 사원번호, 부서명, 도시명, 급여를 출력하시오.(급여의 내림차순으로 정렬)
SELECT EMPLOYEE_ID, DEPARTMENT_NAME, CITY, SALARY FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND  D.LOCATION_ID = L.LOCATION_ID /* 세 개 테이블 조인*/
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES /*전체 사원의 평균급여*/)
ORDER BY SALARY DESC;

25. 110번 부서에서 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진 사원의 LAST_NAME과 부서명을 출력하시오.
SELECT LAST_NAME, DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
     AND E.DEPARTMENT_ID = 110
     AND JOB_ID NOT IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 30);
                             /*30번 부서에 존재하는 직책에 대해 서브쿼리로 뷰를 만들기*/
     
26. 직책(job_id)이 SA_MAN 인 사람들의 최고급여보다 높은 급여를 받는 사원의 사원번호와 급여를 출력하시오.
SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES    
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES WHERE job_id = 'SA_MAN');/* SA_MAN 중 최고급여*/

27. 회사 전체의 최대 연봉, 최소 연봉, 연봉 총합 및 평균 연봉을 자연수로 포맷(ROUND)하여 조회한다.
SELECT MAX(SALARY), MIN(SALARY), SUM(SALARY), ROUND(AVG(SALARY)) FROM EMPLOYEES;

28. 각 JOB_ID 별, 최대 연봉, 최소 연봉, 연봉 총합 및 평균 연봉을 자연수로 포맷하여 조회한다. (JOB_ID 오름차순)
SELECT JOB_ID, MAX(SALARY), MIN(SALARY), SUM(SALARY), ROUND(AVG(SALARY)) FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID ;

29.동일한 직업(JOB_ID 동일)을 가진 사원들의 총 수를 조회한다.(JOB_ID 오름차순)
SELECT JOB_ID, COUNT(EMPLOYEE_ID) FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID ;

30. 매니저로 근무하는 사원들의 총 수를 조회한다.
SELECT COUNT(DISTINCT MANAGER_ID) FROM EMPLOYEES;
     (서브쿼리 있는 쿼리문으로도 작성해보시오. -사원번호를 카운트 하시오.)
SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES
WHERE EMPLOYEE_ID IN (SELECT MANAGER_ID FROM EMPLOYEES);

31. 사내의 최대 연봉 및 최소 연봉의 차이를 조회한다.
SELECT MAX(SALARY),  MIN(SALARY), MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES;

32. 매니저의 사번 및 그 매니저 밑 사원들 중 최소 연봉을 받는 사원의 연봉을 조회한다.
--     매니저가 없는 사람들은 제외한다.
--     연봉 기준 역순으로 조회한다.
SELECT MANAGER_ID, MIN(SALARY) FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
ORDER BY MIN(SALARY) DESC;

--     최소 연봉이 6000 미만인 경우는 제외한다.(HAVING절 이용, 사원의 최소연봉이 6000이상인 매니저만 조회)
SELECT MANAGER_ID, MIN(SALARY) FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING MIN(SALARY) >= 6000
ORDER BY MIN(SALARY) DESC;

--   연봉 6000이상인 사원 중, 최소 연봉을 매니저별로 조회
SELECT MANAGER_ID, MIN(SALARY) FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL AND SALARY >= 6000
GROUP BY MANAGER_ID
ORDER BY MIN(SALARY) DESC;


보너스1) 매니저의 사번 및 그 매니저 밑 사원들 중 최대 연봉을 받는 사원의 연봉을 조회한다.
화면출력 : 매니저 사번, 사원번호 , 최대연봉
SELECT MANAGER_ID, EMPLOYEE_ID, SALARY FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
AND (SALARY, MANAGER_ID) IN (SELECT MAX(SALARY), MANAGER_ID FROM EMPLOYEES
GROUP BY MANAGER_ID);

보너스2) 매니저의 사번 및 그 매니저 밑 사원들 중 최대 연봉을 받는 사원의 연봉을 조회한다.
단, 연봉이 10000이하인 사원 중 최대 연봉 --WHERE
화면출력 : 매니저 사번, 사원번호 , 최대연봉
SELECT MANAGER_ID, EMPLOYEE_ID, SALARY FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL --WHERE SALARY <= 10000 를 사용하면 3번의 HAVING과 동일한 결과
AND (SALARY, MANAGER_ID) IN (SELECT MAX(SALARY), MANAGER_ID FROM EMPLOYEES
WHERE SALARY <= 10000
GROUP BY MANAGER_ID);

보너스3)매니저의 사번 및 그 매니저 밑 사원들 중 최대 연봉을 받는 사원의 연봉을 조회한다.
단, 최대연봉이 10000이하인 사원의 경우에만 출력
화면출력 : 매니저 사번, 사원번호 , 최대연봉
SELECT MANAGER_ID, EMPLOYEE_ID, SALARY FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
AND (SALARY, MANAGER_ID) IN (SELECT MAX(SALARY), MANAGER_ID FROM EMPLOYEES
GROUP BY MANAGER_ID HAVING MAX(SALARY) <= 10000);

보너스 4번)매니저의 사번 및 그 매니저 밑 사원들 중 최대 연봉을 받는 사원의 연봉을 조회한다.
화면출력 : 매니저 사번, 사원번호 , 부서명, 최대연봉
SELECT E.MANAGER_ID, E.EMPLOYEE_ID, D.DEPARTMENT_NAME, E.SALARY
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND (E.MANAGER_ID,E.SALARY) IN (SELECT MANAGER_ID, MAX(SALARY) FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID);

--과정1) 매니저별 최대연봉을 구해놓는다.
SELECT MANAGER_ID, MAX(SALARY) FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID

--과정2) 사원의 매니저번호와 연봉정보가 과정1)과 일치하는 사원정보를 출력한다.
SELECT E.MANAGER_ID, E.EMPLOYEE_ID, D.DEPARTMENT_NAME, E.SALARY ...
WHERE (E.MANAGER_ID,E.SALARY) IN (과정1)

--과정3)부서명을 출력하기 위해 내부조인을 체결한다.
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID

33. 부서 명, 위치 ID, 각 부서 별 사원 총 수, 각 부서 별 평균 연봉을 조회한다.
--     평균 연봉은 소수점 2 자리까지만 표현한다.

SELECT D.DEPARTMENT_NAME AS 부서명, D.LOCATION_ID AS 위치ID,
COUNT(E.EMPLOYEE_ID) AS 사원총수, -- 전체 튜플의 갯수를 파악하기 위해서는 기본키를 COUNT한다.
ROUND(AVG(E.SALARY),2) AS 평균연봉
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME, D.LOCATION_ID;

33-1. 부서 명, 지역명, 각 부서 별 사원 총 수, 각 부서 별 평균 연봉을 조회한다.
--     평균 연봉은 소수점 2 자리까지만 표현한다.
SELECT D.DEPARTMENT_NAME AS 부서명, L.CITY AS 지역명,
COUNT(*) AS 사원총수, ROUND(AVG(E.SALARY),2) AS 평균연봉 -- 전체 갯수를 파악하기 위해 *를 이용해도 됨
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND D.LOCATION_ID = L.LOCATION_ID
GROUP BY D.DEPARTMENT_NAME, L.CITY;

34. 총 사원 수 및 2005, 2006, 2007, 2008 년도 별 고용된 사원들의 총 수를 조회한다.
--(SELECT 절에 사용하는 스칼라 서브쿼리 이용)
총사원 :SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES
2005년도 고용 사원 : SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES WHERE HIRE_DATE LIKE '05%'
....
SELECT DISTINCT
  (SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES) AS 총사원
, (SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES WHERE HIRE_DATE LIKE '05%') AS "2005년"
, (SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES WHERE HIRE_DATE LIKE '06%') AS "2006년"
, (SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES WHERE HIRE_DATE LIKE '07%') AS "2007년"
, (SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES WHERE HIRE_DATE LIKE '08%') AS "2008년"
FROM EMPLOYEES;

35. 각 부서의 직업(JOB_ID) 별 연봉 총 합 및 각 부서별(DEPARTMENT_ID) 연봉 총 합을 조회한다.
--1) 각 부서의 직업(JOB_ID) 별 연봉 총 합
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID

--2) 각 부서별(DEPARTMENT_ID) 연봉 총 합, 스칼라 서브쿼리로
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID --GROUP BY 대신 셀프조인 기법 이용

-- 1)과 2)(스칼라 서브쿼리) 의 조합
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY) AS 부서별직업별총합
,(SELECT SUM(SALARY) FROM EMPLOYEES E1 WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID ) AS 부서별총합
  -- 스칼라 서브쿼리로 작성한 부서별 연봉 총합
FROM EMPLOYEES E2
GROUP BY DEPARTMENT_ID, JOB_ID;

***NVL(판별해야 하는 값, 판별값이 NULL 경우 화면 출력 데이터)
예) SELECT DEPARTMENT_ID, NVL(DEPARTMENT_ID,0) FROM EMPLOYEES;

36. 각 직업 별 부서별(20, 30, 50, 100 부서만) 연봉의 총 합을 조회한다. (NULL 값인 경우 0으로 표시한다.)
-- SELECT JOB_ID, NVL(20번 부서 연봉 총합,0), NVL(30번 부서 총합,0), NVL(50번 부서 총합,0), NVL(100번 부서 총합,0)
-- FROM EMPLOYEES GROUP BY JOB_ID;
-- 각 부서별 연봉 총 합 => SUM(DECODE(DEPARTMENT_ID, 20, SALARY))
-- NVL(SUM(DECODE(DEPARTMENT_ID, 20, SALARY)),0)

SELECT JOB_ID
, NVL(SUM(DECODE(DEPARTMENT_ID, 20, SALARY)),0) AS "20번부서" --NVL(20번 부서 연봉 총합,0)
, NVL(SUM(DECODE(DEPARTMENT_ID, 30, SALARY)),0) AS "30번부서" --NVL(30번 부서 총합,0)
, NVL(SUM(DECODE(DEPARTMENT_ID, 50, SALARY)),0) AS "50번부서" --NVL(50번 부서 총합,0)
, NVL(SUM(DECODE(DEPARTMENT_ID, 100, SALARY)),0) AS "100번부서" --NVL(100번 부서 총합,0)
FROM EMPLOYEES GROUP BY JOB_ID;

37.  LAST_NAME 이 Zlotkey 와 동일한 부서에 근무하는 모든 사원들의 사번 및 고용날짜를 조회한다.
--     결과값에서 Zlotkey 는 제외한다.
SELECT EMPLOYEE_ID , HIRE_DATE FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE LAST_NAME ='Zlotkey')
      --Zlotkey 와 동일한 부서
AND LAST_NAME !='Zlotkey';

38. LAST_NAME 에 u 가 포함되는 사원들과 동일 부서에 근무하는 사원들의 사번 및 LAST_NAME 을 조회한다.
SELECT EMPLOYEE_ID , LAST_NAME FROM EMPLOYEES
WHERE DEPARTMENT_ID IN
                    (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE LAST_NAME LIKE '%u%');

                   
39. 커미션을 버는 사원들의 부서와 연봉이 동일한 사원들의 LAST_NAME, 부서 번호 및 연봉을 조회한다.
SELECT LAST_NAME, DEPARTMENT_ID, SALARY FROM EMPLOYEES
WHERE (DEPARTMENT_ID, SALARY) IN
                       (SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL);
                          -- 커미션을 버는 사원들의 부서와 연봉

***조인문 연습***
J-1) 급여가 3000이상인 사원번호, LAST_NAME, SALARY, 부서명, 도시명을 조회하시오.--내부조인
SELECT  E.EMPLOYEE_ID, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME, L.CITY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID AND D.LOCATION_ID = L.LOCATION_ID
AND E.SALARY >= 3000;

J-2) 급여가 2500 이하이고 사원번호가 200이하인 사원의 LAST_NAME, 부서명을 조회하시오.--내부조인
SELECT E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.SALARY <=2500 AND E.EMPLOYEE_ID <= 200;

J-3) 급여범위가 JOBS 테이블의 최소급여(MIN_SALARY)와 최대급여(MAX_SALARY) 사이에 있는 사원의 LAST_NAME, JOB_ID를 조회하시오.
  --내부조인(비등가조인) , 테이블간의 데카르트의 곱이 발생하여 모든 등급별 연결이 생성된다.
 SELECT E.LAST_NAME, E.JOB_ID
 FROM EMPLOYEES E, JOBS J
 WHERE E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

J-4) 자신의 매니저보다 먼저 고용된 사원들의 LAST_NAME 및 고용일을 조회한다.--셀프조인
SELECT EMP.LAST_NAME, EMP.HIRE_DATE FROM EMPLOYEES EMP, EMPLOYEES MGR
WHERE EMP.MANAGER_ID = MGR.EMPLOYEE_ID
AND EMP.HIRE_DATE < MGR.HIRE_DATE ;-- 먼저 고용된 사원 < 자신의 매니저 고용일


J-5) 사원정보(EMPLOYEE_ID, LAST_NAME, MANAGER_ID)와 사원의 직속 상관정보(EMPLOYEE_ID,LAST_NAME) 조회하시오.--셀프+외부조인
SELECT EMP.EMPLOYEE_ID AS 사원번호, EMP.LAST_NAME AS 사원이름, EMP.MANAGER_ID AS 상관번호,
MGR.EMPLOYEE_ID AS 매니저의사원번호, MGR.LAST_NAME AS 매니저이름
FROM EMPLOYEES EMP, EMPLOYEES MGR
WHERE EMP.MANAGER_ID = MGR.EMPLOYEE_ID(+)/*NULL값을 추가하여 조인을 확장시킴*/
ORDER BY EMP.EMPLOYEE_ID
